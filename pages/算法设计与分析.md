- ![main.pdf](../assets/main_1733968648841_0.pdf)
- 虽然xjy写了很多但是还是缺少些
- ## 一 复杂度计算（必考数学计算题）
	- ![image.png](../assets/image_1733974092414_0.png){:height 106, :width 549}
	- 最烦计算题（但是没办法只能写）
	- CHATGPT回答：
		- 您给出的递归方程的形式大致如下：
		  \begin{cases}
		  O(1) & \text{当 } n=1, \\[6pt]
		  k \cdot T\left(\frac{n}{m}\right) + f(n) & \text{当 } n > 1.
		  \end{cases}
		- 这里的参数 k 与 m 是常数，且通常 $$ \geq 1, m > 1$$ 。函数 f(n) 则描述了合并步骤（或额外计算步骤）的复杂度。
		- 这类递归方程求解最常用的方法是**主定理（Master Theorem）**。主定理的标准形式一般是：$$T(n) = a T\left(\frac{n}{b}\right) + g(n)$$
		  其中 $$a \geq 1, b > 1$$ 均为常数，与您给出的方程中 a=k、b = m 对应，而 g(n)=f(n) 对应。
		- 主定理根据 g(n) 与 $$n^{\log_b a}$$ 的大小关系给出三种情形：
			- **如果** $$f(n) = O(n^{\log_m k - \epsilon})$$ 对于某个 \epsilon > 0，即 f(n) 的增长速度比 $$n^{\log_m k}$$ 慢，那么
			  $$T(n) = \Theta(n^{\log_m k}).$$
			- **如果** $$f(n) = \Theta(n^{\log_m k} \log^r n)$$ 对于某个 $$r \ge 0$$，即 f(n) 的增长速度与 $$n^{\log_m k}$$ 相同量级（可能再乘上一些 $$\log$$ 次幂），那么
			  
			  $$T(n) = \Theta(n^{\log_m k} \log^{r+1} n).$$
			  
			  特别地，如果 $$f(n) = \Theta(n^{\log_m k})$$，则
			  $$T(n) = \Theta(n^{\log_m k} \log n).$$
			- **如果**$$f(n) = \Omega(n^{\log_m k + \epsilon})$$对于某个 $$\epsilon > 0$$，也就是 f(n) 的增长速度比 $$n^{\log_m k} $$快，那么需要检查正则性条件（regularity condition），即：
			  $$k f\left(\frac{n}{m}\right) \leq c f(n)$$
			  
			  对于某个常数 c<1c < 1。若该条件满足，则
			  
			  $$T(n) = \Theta(f(n)).$$
			  
			  总结而言，解决这类递归方程的关键是通过比较 f(n)f(n) 与 nlog⁡mkn^{\log_m k} 的增长速率，然后套用主定理的三种情况求出 T(n)T(n) 的渐进复杂度。
		- 在使用主定理（Master Theorem）求解形如：
		  
		  T(n)=aT(nb)+g(n)T(n) = a T\left(\frac{n}{b}\right) + g(n)
		  
		  的递归式时，我们比较的标准函数是 nlog⁡ban^{\log_b a}。之所以选择这一函数作为比较基准，原因在于：
		- **递归的“分解结构”**：
			- 递归式 $$T\left(\frac{n}{b}\right) + g(n) $$描述了一种分治型算法。这里的参数 a 和 b 决定了问题的分解方式：
				- b > 1 表示每次将问题规模缩小到原来的 $$1/b$$。
				- a≥1 表示每次产生 a 个子问题。
			- 在没有额外的合并开销（即 g(n)=0g(n)=0）的纯递归情形下，递归解大致会呈现如下形式：
			  $$T(n) = a T\left(\frac{n}{b}\right) \implies T(n) = a \cdot a T\left(\frac{n}{b^2}\right) = \dots = a^{\log_b n} T(1)$$
			- 因为在每次递归中，问题规模从 n 缩小到 n/b，再到 $$n/b^2$$ ... 一共会进行约 $$n\log_b n$$ 次分解。当最终规模降到常数时 T(1)=O(1)，则有：$$T(n) \approx a^{\log_b n} = n^{\log_b a}.$$
			- 由此可知，当没有合并开销（或合并开销很小）时，递归的解是 $$n^{\log_b a}$$。这就是为什么 $$n^{\log_b a}$$ 自然成为一个分水岭或基准函数。
		- ![image.png](../assets/image_1734007354782_0.png)
	-
- ## 二 递归与分治 9个案例
  collapsed:: true
	- 看xjy的ppt只补充上面没有的
	- ### 汉诺塔问题
		- ```c++
		  void hanoi(int n,int a, int b, int c){
		    if(n > 0){
		      hanoi(n-1, a, c, b); // 把最底下的经过b放到c上面去
		      move(a,b);	// 把a最底下的放到b上去
		      hanoi(n-1,c,b,a); // 再把c柱子上排好的放b
		    }
		  }
		  ```
	- ### 二分搜索
		- ```c++
		  int binary_search(int arr[], int n, int x){
		    int l = 0, r = n - 1;
		    while (l <= r){
		      int mid = (l + r) / 2;
		      if ( arr[mid] == x) return mid;
		      else if (arr[mi] < x)
		        l = mid + 1;
		      else
		        r = mid - 1;
		    }
		    return -1;
		  }
		  ```
	- 大整数除法
	- Strassen 矩阵乘法
	- 棋盘覆盖
		- ```c++
		  void ChessBoard(int tr, int tc, int dr, int dc,int size){
		    if(size == 1)
		      return;
		    int t = tile++; // 
		    s = size / 2; // 分成四块
		    // 覆盖左上角子棋盘
		    if（ dr < tr+s && dc < tc + s)
		      ChessBoard(tr,tc,dr,dc,s);
		    else{
		      Board[tr+s-1][tc+s-1]=t;	// 用t号L型骨牌覆盖右下角
		      ChessBoard(tr,tc,tr+s-1,tc+s-1,s); // 递归处理这个子块
		    }
		    if ( dr<tr+s && dc >= tc + s )
		      ChessBoard(tr, tc+s,dr,dc,s);
		    else{
		      Board[tr+s-1][tc+s] = t;
		      ChessBoard(tr,tc+s,tr+s-1,tc+s,s);
		    }
		    ...
		  }
		  ```
		- ![image.png](../assets/image_1734005735167_0.png)
	- 合并排序
		- ![image.png](../assets/image_1734005782898_0.png){:height 287, :width 426}
	- ### 快速排序
	  background-color:: red
	- 线性时间选择
	- 最接近点对问题
	- 循环赛日程表
- ## 三 动态规划 （重点）9个案例
  background-color:: red
- ## 四 贪心算法 5个案例
- ## 五 回溯法 11个案例
-
-